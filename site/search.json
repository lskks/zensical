{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.1/","level":1,"title":"1.1 命题","text":"","path":["DiscreteMath","Chapter1 Logic&Proof","1.1 命题"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.1/#_1","level":2,"title":"命题","text":"<p>命题 是一个陈述语句(即陈述事实的语句),它或真或假,但不能既真又假.</p> <p>定义1\\(\\qquad\\)令\\(p\\)为一命题.则\\(p\\)的否定命题记为\\(\\neg p\\)(也可以记为\\(\\over p\\)),指\"不是\\(p\\)所指的情形\",命题\\(\\neg p\\)读作\"非\\(p\\)\",\\(p\\)的否定(\\(\\neg p\\))的真值与\\(p\\)的真值相反.</p> \\(p\\) \\(\\neg p\\) T F F T <p>定义2\\(\\qquad\\)令\\(p\\)和\\(q\\)为命题.\\(p,q\\)的合取即命题\"\\(p\\)并且\\(q\\)\",记作\\(p\\wedge q\\).当\\(p\\)和\\(q\\)都是真时，\\(p\\wedge q\\)命题为真,否则为假.</p> \\(p\\) \\(q\\) \\(p\\wedge q\\) T T T T F F F T F F F F <p>在离散数学中,有时也用\"但是\"表示\"而且\".</p> <p>定义3\\(\\qquad\\)令\\(p\\)和\\(q\\)为命题.\\(p,q\\)的析取即命题\"\\(p\\)或\",记作\\(p\\vee q\\).当\\(p\\)和\\(q\\)均为假时，\\(p\\vee q\\)命题为假,否则为真.</p> \\(p\\) \\(q\\) \\(p\\vee q\\) T T T T F T F T T F F F <p>定义4\\(\\qquad\\) 令\\(p\\)和\\(q\\)为命题.\\(p\\)和\\(q\\)的异或(记作\\(p\\oplus q\\))是这样一个命题:当\\(p\\)和\\(q\\)中恰好只有一个为真时命题为真,否则为假.</p> \\(p\\) \\(q\\) \\(p\\oplus q\\) T T F T F T F T T F F F <p>兼或 是指两命题可以同时成立,异或 指两命题只有一个成立.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.1 命题"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.1/#_2","level":2,"title":"条件语句","text":"<p>定义5\\(\\qquad\\) 令\\(p\\)和\\(q\\)为命题.条件语句\\(p\\to q\\)是命题\"如果\\(p\\),则\\(q\\)\":.当\\(p\\)为真而\\(q\\)为假时,条件语句\\(p\\to q\\)为假,否则为真.在条件语句\\(p\\to q\\)中,\\(p\\)称为假设(前件,前提),\\(q\\)称为结论(后件).</p> \\(p\\) \\(q\\) \\(p\\to q\\) T T T T F F F T T F F T <p>条件语句的其他表示方法</p> <p></p> <p>逆命题、逆否命题与反命题 由条件语句可以构成一些新的条件语句.特别是三个常见的相关条件语句还拥有特殊的名称. 1. 命题\\(q\\to p\\)称为\\(p\\to q\\)的逆命题, 2. 而\\(p\\to q\\)的逆否命题是命题\\(\\neg q\\to\\neg p\\). 3. 命题\\(\\neg p\\to\\neg q\\)称为\\(p\\to q\\)的反命题.</p> <p>双条件命题</p> <p>定义6\\(\\qquad\\) 令\\(p\\)和\\(q\\)为命题.双条件语句\\(p\\leftrightarrow q\\)是命题“\\(p\\)当且仅当\\(q\\)\".当\\(p\\)和\\(q\\)有同样的真值时，双条件语句为真,否则为假.双条件语句也称为双向蕴含.</p> \\(p\\) \\(q\\) \\(p\\leftrightarrow q\\) T T T T F F F T F F F T <p>双条件命题的其他表示方法</p> <ul> <li>\"\\(p\\)是\\(q\\)的充分必要条件\"</li> <li>\"如果\\(p\\),那么\\(q\\),反之亦然\"</li> <li>\"\\(p\\)当且仅当\\(q\\)\"</li> </ul>","path":["DiscreteMath","Chapter1 Logic&Proof","1.1 命题"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.1/#_3","level":2,"title":"复合命题的真值表","text":"<p>真值表的行数\\(r\\)与命题个数\\(n(n\\in\\mathcal{Z_+})\\)的关系为</p> \\[ r=2^n \\] <p>其中T与F各\\(\\dfrac{r}2\\)行</p> <p>给出\\((p\\vee\\neg q)\\to(p\\wedge q)\\)的真值表</p> \\(p\\) \\(q\\) \\(\\neg q\\) \\(p\\vee\\neg q\\) \\(p\\wedge q\\) \\((p\\vee\\neg q)\\to(p\\wedge q)\\) T T F T T T T F T T F F F T F T F T F F T T F F","path":["DiscreteMath","Chapter1 Logic&Proof","1.1 命题"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.1/#_4","level":2,"title":"逻辑运算符的优先级","text":"运算符 优先级 \\(\\neg\\) 1 \\(\\vee\\) 2 \\(\\wedge\\) 3 \\(\\to\\) 4 \\(\\leftrightarrow\\) 5","path":["DiscreteMath","Chapter1 Logic&Proof","1.1 命题"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.1/#_5","level":2,"title":"逻辑运算和位运算","text":"<p>计算机用 位 表示信息.位是一个具有两个可能值的符号,即0和1.位一词的含义来自二进制 数字,因为0和1是数的二进制表示中用到的数字.我们用1表示真,用0表示假.即,1表示T(真), 0表示F(假).如果一个变量的值或为真或为假,则此变量就称为布尔变量.</p> 真值 位 T \\(1\\) F \\(0\\) <p>定义7\\(\\qquad\\) 位串 是0位或多位的序列.位串的长度就是它所含位的数目.</p> <p>我们分别用符号\\(\\vee\\),\\(\\wedge\\)和\\(\\oplus\\)表示 按位OR、按位AND 和 按位XOR 运算.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.1 命题"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.2%20applicationsOfPropositionalLogic/","level":1,"title":"1.2 命题逻辑的应用","text":"","path":["DiscreteMath","Chapter1 Logic&Proof","1.2 命题逻辑的应用"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.2%20applicationsOfPropositionalLogic/#_1","level":2,"title":"语句翻译","text":"<p>各种人类语言常有二义性,把语句翻译成复合命题则可以消除歧义.翻译时也许需要根据语句的含义做一些合理的假设。</p> <p>例1</p> <p>怎样把下面的语句翻译成逻辑表达式?</p> <p>“你可以在校园访问因特网，仅当你主修计算机科学或者你不是新生。”</p> <p>解: 令\\(a,c\\)和\\(f\\)分别表示“你可以在校园访问因特网”、“你主修计算机科   学”和“你是个新生”,上述语句可以译为</p> \\[ a\\to (c\\vee\\neg f) \\]","path":["DiscreteMath","Chapter1 Logic&Proof","1.2 命题逻辑的应用"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.2%20applicationsOfPropositionalLogic/#_2","level":2,"title":"系统规范说明","text":"<p>在描述硬件系统和软件系统时，将自然语言语句翻译成逻辑表达式是很重要的一部分。系 统和软件工程师根据自然语言描述的需求，生成精确而无二义性的规范说明，这些规范说明可作为系统开发的基础。</p> <p>系统规范说明应该是 一致的 ，也就是说，系统规范说明不应该包含可能导致矛盾的相互冲突的需求。当规范说明不一致时，就无法开发出一个满足所有规范说明的系统。</p> <p>例2</p> <p>确定下列系统规范说明是否一致的。</p> <ul> <li>“诊断消息存储在缓冲区中或者被重传。” </li> <li>“诊断消息没有存储在缓冲区中。” </li> <li>“如果诊断消息存储在缓冲区中，那么它被重传。”</li> </ul> <p>解</p> <p>令\\(p\\)为“诊断消息存储在缓冲区中”,\\(q\\)为“诊断消息被重传”,则, 以上语句可以表示为\\(p\\vee q, \\neg p, p\\to q\\) 使\\(p\\)为假,则\\(\\neg p\\)为真,此时,\\(\\neg p, p\\to q\\)均为真. 因此,该系统规范说明是一致的.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.2 命题逻辑的应用"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.2%20applicationsOfPropositionalLogic/#_3","level":2,"title":"布尔搜索","text":"<p>逻辑联结词广泛用于大量信息搜索中，由于搜索采用命题逻辑的技术，所以称为布尔搜索。</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.2 命题逻辑的应用"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.2%20applicationsOfPropositionalLogic/#_4","level":2,"title":"逻辑电路","text":"<p>逻辑电路(或数字电路)接受输入信号\\(p_1,p_2,\\cdots,p_n\\)，每个信号1位[或0(关)或1(开)], 产生输出信号\\(s_1,s_2,\\cdots,s_n\\),每个1位。</p> <p>下图展示了三种基本逻辑门,分别是非门(NOT),或门(OR)以及与门(AND). </p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.2 命题逻辑的应用"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.3%20PropositionalEquivalences/","level":1,"title":"1.3 命题等价式","text":"<p>定义1\\(\\qquad\\)一个真值永远是真的复合命题(无论其中出现的命题变元的真值是什么),称为 永真式 ,也称为 重言式 .一个真值永远为假的复合命题称为 矛盾式 , 既不是永真式又不是矛盾式的复合命题称为 可能式 .</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.3 命题等价式"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.3%20PropositionalEquivalences/#_1","level":2,"title":"逻辑等价式","text":"<p>定义2\\(\\qquad\\)如果\\(p\\leftrightarrow q\\)是永真式,则复合命题\\(p\\)和\\(q\\)称为是逻辑等价的.用记号\\(p\\equiv q\\)表示\\(p\\)和\\(q\\)是逻辑等价的.</p> <p>注意</p> <p>符号\\(\\equiv\\)不是逻辑联结词,\\(p\\equiv q\\)不是一个复合命题,而是代表“\\(p\\to q\\)是永真式” 这一语句. 有时候用符号\\(\\Leftrightarrow\\)来代替\\(\\equiv\\)表示逻辑等价。</p> <p>判定两个复合命题是否等价的方法之一是使用真值表.特别地,复合命题\\(p\\)和\\(q\\)是等价的,当且仅当对应它们真值的两列完全一致</p> <p>常用的逻辑等价式 </p> <p>定义3\\(\\qquad\\)合取与析取  只要\\(p_1,p_2,\\cdots,p_n\\)为命题,\\(p_1\\vee p_2\\vee\\cdots\\vee p_n\\)和\\(p_1\\wedge p_2\\wedge\\cdots\\wedge p_n\\)均有定义.除此以外,德摩根定律可以推广为</p> \\[ \\neg(p_1\\vee p_2\\vee\\cdots\\vee p_n)\\equiv\\neg p_1\\wedge\\neg p_2\\wedge\\cdots\\wedge p_n \\] <p>和</p> \\[ \\neg(p_1\\wedge p_2\\wedge\\cdots\\wedge p_n)\\equiv\\neg p_1\\vee\\neg p_2\\vee\\cdots\\vee p_n \\] <p>或简写为\\(\\neg(\\bigvee_{j=1}^{n}p_j)\\equiv\\bigwedge_{j=1}^{n}\\neg p_j\\)和\\(\\neg(\\bigwedge_{j=1}^{n}p_j)\\equiv\\bigvee_{j=1}^{n}\\neg p_j\\).</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.3 命题等价式"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.3%20PropositionalEquivalences/#_2","level":2,"title":"构造新的逻辑等价式","text":"<p>利用上表中逻辑等价式可以构造出新的命题.</p> 例1 <p>试证明 \\(\\neg(p\\to q)\\equiv p\\wedge\\neg q\\)</p> <p>证明:</p> \\[ \\begin{aligned} \\neg(p\\to q)&amp;\\equiv\\neg(\\neg p\\vee q)\\\\ &amp;\\equiv\\neg(\\neg p)\\wedge\\neg q\\\\ &amp;\\equiv p\\wedge\\neg q \\end{aligned} \\] 例2 <p>试证明 \\(\\neg(p\\vee(\\neg p\\wedge q))\\equiv\\neg p\\wedge\\neg q\\)</p> <p>证明:</p> \\[ \\begin{aligned} \\neg(p\\vee(\\neg p\\wedge q))&amp;\\equiv\\neg p\\wedge\\neg(\\neg p\\wedge q)\\\\ &amp;\\equiv\\neg p\\wedge(p\\vee\\neg q)\\\\ &amp;\\equiv(\\neg p\\wedge p)\\vee(\\neg p\\wedge\\neg q)\\\\ &amp;\\equiv F\\vee(\\neg p\\wedge\\neg q)\\\\ &amp;\\equiv\\neg p\\wedge\\neg q \\end{aligned} \\]","path":["DiscreteMath","Chapter1 Logic&Proof","1.3 命题等价式"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.3%20PropositionalEquivalences/#_3","level":2,"title":"命题的可满足性","text":"<p>如果存在一个对其变元的真值赋值使其为真,则该复合命题称为是 可满足的 .反之,则称该符合命题是 不可满足的.</p> <p>当我们找到一个特定的使得复合命题为真的真值赋值时，就证明了它是可满足的。这样的一个赋值称为这个特定的可满足性问题的一个 解.</p> <p>由可满足性的定义可以知道,永真式和可能式是可满足的;矛盾式是不可满足的.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.3 命题等价式"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.3%20PropositionalEquivalences/#_4","level":2,"title":"可满足性的应用","text":"","path":["DiscreteMath","Chapter1 Logic&Proof","1.3 命题等价式"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.3%20PropositionalEquivalences/#n","level":3,"title":"\\(n\\)皇后问题","text":"<p>\\(n\\)皇后问题要求在一个\\(n\\times n\\)的棋盘上放置\\(n\\)个皇后,并且每一行,每一列以及每一对角线只存在一个皇后. 如图为一个\\(8\\times8\\)的\\(8\\)皇后的解.</p> <p></p> <p>分析: 1. 确保每一行至少有 \\(1\\) 个皇后:    $$    Q_1 = \\bigwedge\\limits_{i=1}^n \\bigvee\\limits_{j=1}^n p(i, j)    $$</p> <ol> <li> <p>确保每一行至多有 \\(1\\) 个皇后:    $$    Q_2 = \\bigwedge\\limits_{i=1}^n \\bigwedge\\limits_{j=1}^{n-1} \\bigwedge\\limits_{k=j+1}^n (\\neg p(i, j)) \\vee (\\neg p(i, k))    $$</p> </li> <li> <p>确保每一列至多有 \\(1\\) 个皇后:    $$    Q_3 = \\bigwedge\\limits_{j=1}^n \\bigwedge\\limits_{i=1}^{n-1} \\bigwedge\\limits_{k=i+1}^n (\\neg p(i, j)) \\vee (\\neg p(k, j))    $$</p> </li> <li> <p>确保对角线不包含两个皇后:</p> </li> <li>左下到右上的对角线：      $$      Q_4 = \\bigwedge\\limits_{i=2}^n \\bigwedge\\limits_{j=1}^{n-1} \\bigwedge\\limits_{k=1}^{\\min(i-1, n-j)} (\\neg p(i, j)) \\vee (\\neg p(i-k, k+j))      $$</li> <li> <p>左上到右下的对角线:      $$      Q_5 = \\bigwedge\\limits_{i=1}^n \\bigwedge\\limits_{j=1}^{n-1} \\bigwedge\\limits_{k=1}^{\\min(n-i, n-j)} (\\neg p(i, j)) \\vee (\\neg p(i+k, k+j))      $$</p> </li> <li> <p>综合公式:    $$    Q = Q_1 \\wedge Q_2 \\wedge Q_3 \\wedge Q_4 \\wedge Q_5    $$</p> </li> </ol>","path":["DiscreteMath","Chapter1 Logic&Proof","1.3 命题等价式"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.4%20Predicates&Quantifiers/","level":1,"title":"1.4 谓词和量词","text":"","path":["DiscreteMath","Chapter1 Logic&Proof","1.4 谓词和量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.4%20Predicates&Quantifiers/#_1","level":2,"title":"谓词","text":"<p>涉及\\(n\\)个变量 \\(x_1,x_2,\\cdots,x_n\\) 如的语句可以表示成,</p> \\[ P(x_1,x_2,\\cdots,x_n) \\] <p>形式为 \\(P(x_1,x_2,\\cdots,x_n)\\) 的语句是命题函数 \\(P\\) 在\"\\(n\\)元组 \\((x_1,x_2,\\cdots,x_n)\\) 的值，\\(P\\) 也称为“ \\(n\\) 位谓词\"或\"\\(n\\)元谓词\".</p> <p>描述合法输入的语句叫做 前置条件，而程序运行的输出应该满足的条件称为 后置条件.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.4 谓词和量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.4%20Predicates&Quantifiers/#_2","level":2,"title":"量词","text":"<p>处理谓词和量词的逻辑领域称为 谓词演算。</p> <p>许多数学命题断言某一性质对于变量在某一特定域内的所有值均为真，这一特 定域称为变量的 论域(或 全体域)时常简称为 域.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.4 谓词和量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.4%20Predicates&Quantifiers/#_3","level":4,"title":"全称量词","text":"<p>定义1\\(\\qquad\\)\\(P(x)\\)的全称量化是语句</p> \\[ P(x)对在其论域的所有值为真. \\] <p>符号\\(\\forall xP(x)\\)表示\\(P(x)\\)的全称量化,其中\\(\\forall\\)称为 全称量词。命题 \\(\\forall xP(x)\\) 读做“对所有\\(x\\),\\(P(x)\\)”或“对每个\\(x\\),\\(P(x)\\)”. 一个使\\(P(x)\\)为假的个体称为\\(\\forall xP(x)\\)的反例.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.4 谓词和量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.4%20Predicates&Quantifiers/#_4","level":4,"title":"存在量词","text":"<p>定义2\\(\\qquad\\)\\(P(x)\\)的存在量化是语句</p> \\[ 论域中存在一个x满足P(x) \\] <p>符号\\(\\exists xP(x)\\)表示\\(P(x)\\)的全称量化,其中\\(\\exists\\)称为 存在量词.</p> <p>Note</p> <p>“对某些”,“至少有一个”或“有”; 存在量词可读做 “有一个\\(x\\)满足\\(P(x)\\)” “至少有一个\\(x\\)满足\\(P(x)\\)” 或 “对某个\\(x\\)，\\(P(x)\\)\".</p> <p>全称量词和存在量词可以用如下的方式进行表示</p> \\[\\begin{aligned} \\forall P(x)&amp;\\equiv P(x_1)\\wedge P(x_2)\\wedge\\cdots\\wedge P(x_n)\\\\ \\exists P(x)&amp;\\equiv P(x_1)\\vee P(x_2)\\vee\\cdots\\vee P(x_n) \\end{aligned}\\] <p>如果\\(P(x)\\)是语句“\\(x&gt;10\\)”，论域为不超过4的正整数，则\\(\\exists P(x)\\)的真值是什么?</p> <p>解: 论域为\\(\\{1,2,3,4\\}\\),则</p> \\[ \\exists P(x)\\equiv P(1)\\vee P(2)\\vee P(3)\\vee P(4) \\] <p>因为\\(P(4)=4^2&gt;10\\),所以\\(\\exists P(x)\\)为假.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.4 谓词和量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.4%20Predicates&Quantifiers/#_5","level":4,"title":"唯一性量词","text":"<p>用符号\\(\\exists!\\)或\\(\\exists_1\\)表示唯一性量词,这种表示法是指“存在一个唯一的\\(x\\)使得\\(P(x)\\)为真”。</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.4 谓词和量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.4%20Predicates&Quantifiers/#_6","level":4,"title":"优先级","text":"<p>量词\\(\\forall\\)和\\(\\exists\\)比命题演算中的所有逻辑运算符都具有更高的优先级.</p> <p>\\(\\forall P(x)\\vee Q(x)\\)表示\\((\\forall P(x))\\vee Q(x)\\)而不是\\(\\forall (P(x)\\vee Q(x))\\).</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.4 谓词和量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.4%20Predicates&Quantifiers/#_7","level":4,"title":"变量绑定","text":"<p>当量词作用于变量\\(x\\)时，我们说此变量的这次出现为约束的。 一个变量如果没有被量词约束或设置为等于某一特定值,则它的出现被称为是自由的.</p> <p>命题函数中的所有变量出现必须是约束的或者被设置为等于某个特定值的，才能把它转变为一个命题。</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.4 谓词和量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.4%20Predicates&Quantifiers/#_8","level":2,"title":"涉及量词的逻辑等价式","text":"<p>定义3\\(\\qquad\\)涉及谓词和量词的语句是逻辑等价的当且仅当无论用什么谓词代入这些语句,也无论为这些命题函数里的变量指定什么论域,它们都有相同的真值.我们用\\(S\\equiv T\\)表示涉及谓词和量词的两个语句\\(S\\)和\\(T\\)是逻辑等价的.</p> \\[\\begin{aligned} \\forall x(P(x)\\vee Q(x))\\equiv\\forall xP(x)\\vee\\forall xQ(x)\\\\ \\forall x(P(x)\\wedge Q(x))\\equiv\\forall xP(x)\\wedge\\forall xQ(x) \\end{aligned}\\]","path":["DiscreteMath","Chapter1 Logic&Proof","1.4 谓词和量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.4%20Predicates&Quantifiers/#_9","level":2,"title":"量化表达式的否定","text":"\\[\\begin{align} \\neg\\forall xP(x)\\equiv\\exists x\\neg P(x)\\\\ \\neg\\exists xP(x)\\equiv\\forall x\\neg P(x) \\end{align} \\]","path":["DiscreteMath","Chapter1 Logic&Proof","1.4 谓词和量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.5%20NestedQuantifiers/","level":1,"title":"1.5 嵌套量词","text":"<p>嵌套量词 是指一个量词出现在另一个量词的作用域内.</p> <p>在处理多个变量的量化式时,可以借助嵌套循环的思想来理解.</p> <ul> <li>对于 \\(\\forall x\\forall yP(x,y)\\)，当所有情况均为真时，结果为真；否则为假</li> <li>对于 \\(\\forall x\\exists yP(x,y)\\)，对于每一趟外层循环，只要有一种子情况为真，结果为真；否则为假</li> <li>对于 \\(\\exists x\\forall yP(x,y)\\)，如果存在一趟外层循环，其所有子情况均为真，结果为真；否则为假</li> <li>对于 \\(\\exists x\\exists yP(x,y)\\)，只要有一种情况为真，结果为真；否则为假</li> </ul>","path":["DiscreteMath","Chapter1 Logic&Proof","1.5 嵌套量词"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.6%20InferRule/","level":1,"title":"1.6 推理规则","text":"","path":["DiscreteMath","Chapter1 Logic&Proof","1.6 推理规则"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.6%20InferRule/#_1","level":2,"title":"命题逻辑的有效论证","text":"<p>定义1</p> <p>论证是一连串的命题。 前提是除了论证中最后一个命题外的其他命题 结论是论证中最后那个命题 论证形式是一连串涉及命题变量复合命</p> <p>有效性(valid) 无论用什么特定命题来替换中的命题变量，如果前提均真时结论为真，则称该论证形式是有效的. 当一个论证的所有前提为真蕴含着结论为真,则这个论证是有效的.</p> <p>当\\((p_1\\wedge p_2\\wedge\\cdots\\wedge p_n)\\to q\\)是永真式时,以\\(p_1,p_2,\\cdots,p_n\\)为前提,以\\(q\\)为结论的论证形式是有效的</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.6 推理规则"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.6%20InferRule/#_2","level":1,"title":"命题逻辑的推理规则","text":"<p>![[rulesOfInference.png]]</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.6 推理规则"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.6%20InferRule/#_3","level":1,"title":"使用推理规则建立论证","text":"<p>当有多个前提时，常常需要用到多个推理规则来证明一个论证是有效的,比如下面的例子</p> <p>针对假设\\(p\\to q,\\neg p\\to r\\),以及 \\(r\\to s\\)和结论\\(\\neg q\\to s\\),给出一个有效论证。 解:</p> \\[ \\begin{align} &amp;p\\to q\\\\ &amp;\\neg q\\to\\neg p\\\\ &amp;\\neg p\\to r\\\\ &amp;\\neg q\\to r\\\\ &amp;r\\to s\\\\ &amp;\\neg q\\to s \\end{align} \\]","path":["DiscreteMath","Chapter1 Logic&Proof","1.6 推理规则"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.6%20InferRule/#_4","level":1,"title":"消解律","text":"<p>消解率基于以下的永真式</p> \\[ (p\\vee q)\\wedge(\\neg p\\vee r)\\to(q\\vee r) \\] <p>其中命题\\(q\\vee r\\)被称为消解式.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.6 推理规则"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.6%20InferRule/#_5","level":1,"title":"谬误","text":"<p>常见的谬误一般是基于可能式而非永真式,例如 $$ ((p\\to q)\\wedge q)\\to p $$ 前提为真,但结论不一定正确,这类不正确的推理称为肯定结论的谬误</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.6 推理规则"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.6%20InferRule/#_6","level":1,"title":"量化命题的推理规则","text":"<p>![[quantified-rule.png]]</p> <p>全称假言推理</p> \\[ \\begin{aligned} &amp;\\forall(P(x)\\to Q(x))\\\\ &amp;\\underline{P(a),a\\text{是论域中的一个特定元素}}\\\\ \\therefore &amp;Q(a) \\end{aligned} \\] <p>全称取拒式</p> \\[ \\begin{aligned} &amp;\\forall(P(x)\\to Q(x))\\\\ &amp;\\underline{\\neg Q(a),a\\text{是论域中的一个特定元素}}\\\\ \\therefore &amp;\\neg (a) \\end{aligned} \\]","path":["DiscreteMath","Chapter1 Logic&Proof","1.6 推理规则"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.7%20introProof/","level":1,"title":"1.7 证明导论","text":"","path":["DiscreteMath","Chapter1 Logic&Proof","1.7 证明导论"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.7%20introProof/#_1","level":2,"title":"术语","text":"<p>定理: 是一个能够被证明是真的语句.</p> <p>定理一词通通常是用来专指那些被认为至少有些重要的语句。</p> <p>不太重要的定理有时称为命题(定理也可以称为事实或结论.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.7 证明导论"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter1%20Logic&Proof/1.7%20introProof/#_2","level":2,"title":"直接证明法","text":"<p>条件语句\\(p\\to q\\)的直接证明法的构造：首先假设\\(p\\)为真,然后用推理规则构造，最后表明\\(q\\)必须也为真.</p> <p>定义 1\\(\\qquad\\)如果存在一个整数\\(k\\),使得\\(n=2k\\),那么\\(n\\)为偶数;如果存在一个整数\\(k\\)使得\\(n=2k+1\\),那么\\(n\\)为奇数</p> <p>定理 1\\(\\qquad\\)如果\\(n\\)是偶数,则\\(n^2\\)也是偶数.</p> <p>证明:</p> <p>假设\\(n\\)是偶数,则存在一个整数\\(k\\)使得\\(n=2k\\).</p> <p>那么</p> \\[ n^2=(2k)^2=4k^2=2(2k^2) \\] <p>因此\\(n^2\\)也是偶数.</p>","path":["DiscreteMath","Chapter1 Logic&Proof","1.7 证明导论"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.1%20set/","level":1,"title":"2.1 集合","text":"<p>定义1\\(\\qquad\\)集合是对象的一个无序的聚集,对象也称为集合的元素或成员.集合包含它的元素.</p> <p>\\(a\\in A\\)表示\\(a\\)是集合\\(A\\)中一个元素; \\(a\\notin A\\)表示\\(a\\)不是集合\\(A\\)中的一个元素.</p> <p>描述集合有多种方式.一种方式是在可能的情况是在花括号之间列出所有元素.这种描述集合的方式也称为是 花名册方法.</p> <p>例子</p> 例1例2例3 <p>英语字母表中所有元音字母的集合\\(V\\)可以表示为\\(V=\\{a, e, i, o, u\\}\\).</p> <p>小于10的正奇数集合\\(O\\)可以表示为\\(O=\\{1,3,5,7,9\\}\\).</p> <p>小于100的正整数集合可以表示为\\(\\{1,2,3,\\cdots,99\\}\\).</p> <p>如例3所示,用花名册方法表示集合时并不需要列出它的所有元素,可以先列出集合中的某些元素，当元素的一般规律显而易见时就用省略号(\\(\\cdots\\))代替.</p> <p>描述集合的另一种方式是使用 集合构造器 符号.</p> <p>例子</p> 例1例2 <p>小于10的正奇数集合\\(O\\)可以表示为</p> \\[ O=\\{x\\in\\mathbf{Z^+}|x为奇数,x&lt;10\\} \\] <p>所有正有理数集合 可以被写为</p> \\[ Q^+ = \\left\\{ z\\in R | x = p/q,p和q为正整数\\right\\} \\] <p>一些常用的数集如下:</p> \\[\\begin{aligned} &amp;\\mathbf{N} =\\{0,1,2,3,\\cdots\\},\\text{自然数集}\\\\ &amp;\\mathbf{Z} =\\{\\cdots,-1,0,1,\\cdots\\},\\text{整数集}\\\\ &amp;\\mathbf{Z^+}=\\{1,2,3,\\cdots\\},\\text{正整数集}\\\\ &amp;\\mathbf{Q}=\\{p/q|p\\in \\mathbf{Z},q\\in\\mathbf{Z},q\\ne0 \\},\\text{有理数集}\\\\ &amp;\\mathbf{R},\\text{实数集}\\\\ &amp;\\mathbf{R^+},\\text{正实数集}\\\\ &amp;\\mathbf{C},\\text{复数集} \\end{aligned} \\] <p>对于实数\\(a,b\\)且\\(a&lt;b\\),实数 区间:</p> \\[ \\begin{aligned} \\ [a,b\\ ]=\\{x\\mid a\\le x\\le b\\}\\\\\\\\ (a,b\\ ]=\\{x\\mid a&lt; x\\le b\\}\\\\\\\\ \\ [a,b\\ )=\\{x\\mid a\\le x&lt; b\\}\\\\\\\\ \\ (a,b\\ )=\\{x\\mid a&lt; x&lt; b\\}\\\\\\\\ \\end{aligned} \\] <p>其中,\\([a,b]\\)称为闭区间,\\((a,b)\\)称为开区间,\\([a,b)\\)和\\((a,b]\\)称为半开半闭区间.</p> <p>定义2\\(\\qquad\\)两个集合相等当且仅当它们具有相同的元素,即对于集合\\(A\\)和集合\\(B\\)有</p> \\[ \\forall x(x\\in A\\leftrightarrow x\\in B) \\] <p>记为\\(A=B\\).</p> <p>朴素集合论可能会导致一些悖论</p>","path":["DiscreteMath","Chapter2 BasicStructure","2.1 集合"],"tags":[]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.1%20set/#_1","level":2,"title":"韦恩图","text":"<p>全集\\(U\\)用矩形表示,全集中的集合用圆形或者其它图形表示,集合中的特定元素用点表示. </p>","path":["DiscreteMath","Chapter2 BasicStructure","2.1 集合"],"tags":[]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.1%20set/#_2","level":2,"title":"子集","text":"<p>定义3\\(\\qquad\\)当且仅当集合\\(A\\)中的元素也是集合\\(B\\)的元素,那么集合\\(A\\)是集合\\(B\\)的子集,集合\\(B\\)是集合\\(A\\)的超集,即</p> \\[ \\forall x(x\\in A\\to x\\in B) \\] <p>记为\\(A\\subseteq B\\)和\\(B\\supseteq A\\).</p> <p>证明方法</p> <ul> <li>证明\\(A\\)是\\(B\\)的子集:需要证明如果\\(x\\in A\\)那么\\(x\\in B\\).</li> <li>证明\\(A\\)不是\\(B\\)的子集:需要找一个\\(x\\in A\\)使\\(x\\notin B\\).</li> <li>证明两个集合相等:需要证明\\(A\\subseteq B\\)和\\(B\\subseteq A\\).</li> </ul> <p>定理1\\(\\qquad\\)对于任意集合\\(x\\)有(i)\\(\\varnothing\\subseteq S\\), (ii)\\(S\\subseteq S\\) 证明: (i). 根据子集的定义有\\(\\forall x(x\\in \\varnothing\\to x\\in S)\\),因为\\(\\varnothing\\)中没有元素,所以\\(x\\in\\varnothing\\)一定为假 当前提为假时,条件语句一定为真. (ii) 根据子集的定义有\\(\\forall x(x\\in S\\to x\\in S)\\),显然成立.</p> <p>当\\(A\\)是\\(B\\)的子集且\\(A\\ne B\\)时,则\\(A\\)是\\(B\\)的真子集,记为\\(A\\subset B\\).</p>","path":["DiscreteMath","Chapter2 BasicStructure","2.1 集合"],"tags":[]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.1%20set/#_3","level":2,"title":"集合的大小","text":"<p>定义4\\(\\qquad\\)如果集合\\(S\\)中恰有\\(n\\)个不同元素(\\(n\\)为非负整数),则\\(S\\)为有限集,\\(n\\)称为\\(S\\)的基数,记为\\(|S|\\).</p> <p>空集没有元素,所以\\(|\\varnothing|=0\\).</p> <p>定义5\\(\\qquad\\)．如果一个集合不是有限的,则称其是无限的.</p>","path":["DiscreteMath","Chapter2 BasicStructure","2.1 集合"],"tags":[]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.1%20set/#_4","level":2,"title":"幂集","text":"<p>定义6\\(\\qquad\\)给定集合\\(S\\),\\(S\\)的幂集是集合\\(S\\)所有子集的集合.记为\\(\\mathcal{P}(S)\\).</p> <p>空集的幂集</p> \\[ \\begin{aligned} &amp;\\mathcal{P}(\\varnothing)=\\{ \\varnothing\\}\\\\ &amp;\\mathcal{P}(\\{\\varnothing\\})=\\{\\varnothing,\\{\\varnothing\\}\\} \\end{aligned} \\]","path":["DiscreteMath","Chapter2 BasicStructure","2.1 集合"],"tags":[]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.1%20set/#_5","level":2,"title":"笛卡尔积","text":"<p>定义7\\(\\qquad\\)有序\\(n\\)元组\\((a_1, a_2, \\cdots , a_n)\\)是以\\(a_1\\)为第\\(1\\)个元素,\\(a_2\\)为第\\(2\\)个元素,\\(\\cdots\\),\\(a_n\\)为第\\(n\\)个元素的有序聚集.</p> <p>两个有序\\(n\\)元组是相等的当且仅当每一对对应的元素都相等.</p> <p>定义8\\(\\qquad\\)集合\\(A\\)和\\(B\\)的笛卡儿积用\\(A\\times B\\)表示,是所有序偶\\((a, b)\\)的集合,其中\\(a\\in A\\)且\\(b\\in B\\).于是</p> \\[ A\\times B=\\{(a,b)\\mid a\\in A\\wedge b\\in B\\} \\] <p>注意</p> <p>\\(A\\times B\\)与\\(B\\times A\\)所得结果不同,除非当\\(A=\\varnothing\\)或\\(B=\\varnothing\\).</p> <p>定义9\\(\\qquad\\)集合\\(A_1,A_2,\\cdots,A_n\\)的笛卡儿积用\\(A_1\\times A_2\\times A_3\\times\\cdots\\times A_n\\)表示，是有序\\(n\\)元组\\((a_1,a_2,\\cdots,a_n)\\)的集合，其中 \\(a_i\\)属于\\(A_i\\),\\(i= 1,2,\\cdots,n\\).换言之</p> \\[ A_1\\times A_2\\times\\cdots\\times A_n=\\left\\{(a_1,a_2,\\cdots\\,a_n)\\mid a_i\\in A_i,i=1,2,\\cdots,n\\right\\} \\] <p>给定谓词\\(P\\)和论域\\(D\\),则\\(P\\)的真值集为\\(D\\)中使\\(P(x)\\)为真的元素\\(x\\)组成的集合.\\(P(x)\\)的真值集记为\\(\\{x\\in D \\mid P(x)\\}\\).</p>","path":["DiscreteMath","Chapter2 BasicStructure","2.1 集合"],"tags":[]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.2%20setOperator/","level":1,"title":"2.2 集合的运算","text":"<p>定义1\\(\\qquad\\)集合\\(A\\)和集合\\(B\\)的并集是一个包含\\(A\\)或包含\\(B\\)或同时在\\(A\\)和\\(B\\)中的元素组成的集合,记为\\(A\\cup B\\).</p> \\[ A\\cup B=\\{x\\mid x\\in A\\vee x\\in B\\} \\] <p>定义2\\(\\qquad\\)集合\\(A\\)和集合\\(B\\)的交集是一个由同时在\\(A\\)和\\(B\\)中的元素组成的集合,记为\\(A\\cap B\\).</p> \\[ A\\cap B=\\{x\\mid x\\in A\\wedge x\\in B\\} \\] <p></p> <p>定义3\\(\\qquad\\)如果两个集合的交集为空,则称它们是不相交的.</p> <p>容斥原理</p> \\[ |A\\cup B| = |A|+|B|-|A\\cap B| \\] <p>定义4\\(\\qquad\\)集合\\(A\\)和集合\\(B\\)的差集是一个包含\\(A\\)的元素但不包含\\(B\\)的元素的集合,记为\\(A- B\\).</p> \\[ A- B=\\{x\\mid x\\in A\\wedge x\\notin B\\} \\] <p>定义5\\(\\qquad\\)集合\\(A\\)在全集\\(U\\)上的补集记为\\(\\overline{A}\\).</p> \\[ \\overline{A}=\\{x\\in U|x\\notin A\\} \\] <p></p>","path":["DiscreteMath","Chapter2 BasicStructure","2.2 集合的运算"],"tags":[]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.2%20setOperator/#_1","level":2,"title":"集合恒等式","text":"<p>常用的集合恒等式见下图</p> <p></p> <p>证明集合恒等式的方法</p> <ul> <li>子集法</li> <li>成员表</li> <li>利用已知的恒等式</li> </ul>","path":["DiscreteMath","Chapter2 BasicStructure","2.2 集合的运算"],"tags":[]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.2%20setOperator/#_2","level":2,"title":"拓展的并集与交集","text":"<p>定义6\\(\\qquad\\)一组集合的并集是指至少包含这组集合中一个集合成员的元素的集合. 可以用记号</p> \\[ \\bigcup_{i=1}^{n}A_i=A_1\\cup A_2\\cdots\\cup A_n \\] <p>表示集合\\(A_1,A_2,\\cdots,A_n\\)的并集.</p> <p>定义7\\(\\qquad\\)一组集合的交集是指同时包含这组集合中集合成员的元素的集合. 可以用记号</p> \\[ \\bigcap_{i=1}^{n}A_i=A_1\\cap A_2\\cdots\\cap A_n \\] <p>表示集合\\(A_1,A_2,\\cdots,A_n\\)的交集.</p>","path":["DiscreteMath","Chapter2 BasicStructure","2.2 集合的运算"],"tags":[]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.2%20setOperator/#_3","level":2,"title":"多重集","text":"","path":["DiscreteMath","Chapter2 BasicStructure","2.2 集合的运算"],"tags":[]},{"location":"DiscreteMath/Chapter2%20BasicStructure/2.3%20function/","level":1,"title":"2.3 函数","text":"<p>定义1\\(\\qquad\\)从非空集合\\(A\\)和\\(B\\)的函数\\(f\\)是对元素的一种指派:对\\(A\\) 的每个元素恰好指派\\(B\\) 的一个元素。 如果B 中元素b 是唯一由函数f指派给A 中元素a 的，则我们就写成\\(f(a)=b\\).如果\\(f\\)是从\\(A\\) 到\\(B\\)的函数，就写成\\(f:A\\to B\\).</p> <p>函数有时也称为 映射 或者 变换。</p> <p>定义 2 如果\\(f\\)是从\\(A\\) 到\\(B\\) 的函数，那么\\(A\\)是\\(f\\)的定义域,而\\(B\\)是\\(f\\)的陪域. 如果\\(f(a)=b\\)，那么\\(b\\) 是\\(a\\)的像,而 \\(a\\) 是\\(b\\) 的原像. \\(f\\)的值域或像是 \\(A\\) 中元素的所有像的集合。 如果 \\(f\\)是从\\(A\\) 到 \\(B\\) 的函数，我们说\\(f\\)把\\(A\\) 映射（map）到 \\(B\\)。</p>","path":["DiscreteMath","Chapter2 BasicStructure","2.3 函数"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter3%20Algorithm/algotithm/","level":1,"title":"3.1 算法","text":"<p>定义1\\(\\qquad\\)算法是进行一项计算或解决一个问题的精确指令的有限序列.</p> <p>算法1</p> \\[ \\begin{aligned} &amp;\\text{寻找有限序列中的最大值}\\\\ &amp;\\mathbf{procedure}\\ max\\{a_1,a_2,\\cdots,a_n:\\text{integers}\\}\\\\ &amp;max:=a_1\\\\ &amp;\\mathbf{for}\\ i:= 2\\ \\mathbf{to}\\ n\\\\ &amp;\\qquad\\mathbf{if}\\ max&lt;a_i\\ \\mathbf{then}\\ max := a_i\\\\ &amp;\\mathbf{return}\\ max \\end{aligned} \\] <p>算法1的C++实现 <pre><code>int find_max_element(int* arr, int n)\n{\n    int max = arr[0];\n    for (int i = 1;i &lt; n;i++)\n    {\n        if (max &lt; a[i])\n            max = a[i];\n    }\n    return max;\n}\n</code></pre></p> <p>Note</p> <ul> <li>输入: 算法从一个指定的集合得到输入值</li> <li>输出: 对每个输入值集合,算法都要从一个指定的集合中产生输出值.输出值就是问题的解</li> <li>确定性: 算法的步骤必须是准确定义的</li> <li>正确性: 对每一组输入值,算法都应产生正确的输出值</li> <li>有限性: 对任何输入算法都应在有限(可能很多)步之后产生期望的输出</li> <li>有效性: 算法的每一步都应能够准确地在有限时间内完成</li> <li>通用性: 算法过程应该可以应用于期望形式的所有问题,而不只是用于一组特定的输入值.</li> </ul>","path":["DiscreteMath","Chapter3 Algorithm","3.1 算法"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter3%20Algorithm/algotithm/#_1","level":1,"title":"搜索算法","text":"\\[ \\begin{aligned} &amp;\\text{线性搜索算法}\\\\ &amp;\\mathbf{procedure}\\ linear\\ search(x:\\text{integers},a_1,a_2,\\cdots a_n:\\text{distinct integers}\\}\\\\ &amp;i:=1\\\\ &amp;\\mathbf{while}\\ (i&lt;n\\ \\mathbf{and}\\ x\\ne a_i)\\\\ &amp;\\mathbf{if}\\ i\\le n\\ \\mathbf{then}\\ location := i\\\\ &amp;\\mathbf{else}\\ location := 0\\\\ &amp;\\mathbf{return}\\ location \\end{aligned} \\] <p>线性搜索算法的C++实现</p> <pre><code>int linear_search(int* arr, int n, int x)\n{\n    int i, location = 1;\n    while (i &lt;= n &amp;&amp; x != arr[i])\n    {\n        i++;\n    }\n    if (i &lt;= n)\n        location = i;\n    else\n        location = 0;\n    return location;\n}\n</code></pre>","path":["DiscreteMath","Chapter3 Algorithm","3.1 算法"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter3%20Algorithm/function/","level":1,"title":"3.2 函数的增长","text":"<p>3.2 函数的增长</p>","path":["DiscreteMath","Chapter3 Algorithm","3.2 函数的增长"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter3%20Algorithm/function/#o","level":2,"title":"大\\(O\\)记号","text":"<p>定义1\\(\\qquad\\)如果\\(f\\)和\\(g\\)是从整数集或实数集到实数集的函数,存在常数\\(C\\)和\\(k\\),当\\(x&gt;k\\)时有</p> \\[ \\lvert f(x)\\rvert\\le C\\lvert g(x)\\rvert \\] <p>那么\\(f(x)\\)是\\(O(g(x))\\)的,也可记为\\(f(x)=O(g(x))\\).</p> <p>如何利用大\\(O\\)记号的定义</p> <p>首先,选择一个特定的\\(k\\)值,估算\\(x&gt;k\\)时\\(f(x)\\)的值,再利用估算的值寻找\\(C\\) </p> <p>如果\\(f(x)\\)是\\(O(g(x))\\)且\\(g(x)\\)是\\(O(f(x))\\),那么\\(f(x)\\)和\\(g(x)\\)是同阶的.</p> <p>可以将\\(g(x)\\)替换为更大的绝对值函数,也就是说,如果</p> \\[ \\lvert f(x)\\rvert\\le\\lvert O(g(x))\\rvert\\qquad x&gt;k \\] <p>并且对于所有的\\(x&gt;k\\),有\\(\\lvert g(x)\\rvert\\le\\lvert h(x)\\rvert\\),那么</p> \\[ \\lvert f(x)\\rvert\\le\\lvert O(h(x))\\rvert\\qquad x&gt;k \\] <p>即\\(f(x)\\)是\\(O(g(x))\\)的.</p>","path":["DiscreteMath","Chapter3 Algorithm","3.2 函数的增长"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter3%20Algorithm/function/#o_1","level":1,"title":"一些函数的大\\(O\\)估算","text":"<p>定理1\\(\\qquad\\)令\\(f(x)=a_nx^n+a_{n-1}x^{n-1}+\\cdots+a_1x+a_0\\),其中\\(a_n,a_{n-1},\\cdots,a_1,a_0\\)是实数,那么\\(f(x)\\)是\\(O(x^n)\\)的.</p> <p>证明</p> <p>利用三角不等式</p> \\[ \\begin{aligned} \\lvert f(x)\\rvert&amp;=\\lvert a_nx^n+a_{n-1}x^{n-1}+\\cdots+a_1x+a_0\\rvert\\\\ &amp;\\le\\lvert a_n\\rvert x^n+\\lvert a_{n-1}\\rvert x^{n-1}+\\cdots+\\lvert a_1\\rvert x+\\lvert a_0\\rvert\\\\ &amp;\\le x^n\\left(\\lvert a_n\\rvert+\\lvert a_{n-1}\\rvert/x +\\cdots+\\lvert a_1\\rvert/x^{n-1} +\\lvert a_0\\rvert/   x^n\\right)\\\\ &amp;\\le x^n (\\lvert a_n\\rvert+\\lvert a_{n-1}\\rvert +\\cdots+\\lvert a_1\\rvert +\\lvert a_0\\rvert) \\end{aligned} \\] <p>当\\(x&gt;1\\)时,有</p> \\[ f(x)\\le C\\lvert x^n\\rvert \\] <p>其中\\(C=a_n+a_{n-1}+\\cdots+a_1+a_0\\).  \\(n!\\)是\\(O(n^n)\\)的,\\(\\log n!\\)是\\(O(n\\log n)\\)的</p> <p>常用的估计时间复杂度的函数有</p> \\[ 1,\\log n,n,n\\log n,n^2,2^n,n! \\] <p></p>","path":["DiscreteMath","Chapter3 Algorithm","3.2 函数的增长"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter3%20Algorithm/function/#_1","level":2,"title":"组合函数的增长","text":"<p>定理2\\(\\qquad\\)如果\\(f_1(x)\\)是\\(O(g_1(x))\\),\\(f_2(x)\\)是\\(O(g_2(x))\\),那么\\((f_1+f_2)(x)\\)是\\(O(g(x))\\)的,其中\\(g(x)=\\max(\\lvert g_1(x)\\rvert, \\lvert g_2(x)\\rvert)\\).</p> <p>证明</p> <p>因为\\(f_1(x)\\)是\\(O(g_1(x))\\),\\(f_2(x)\\)是\\(O(g_2(x))\\), 所以\\(f_1(x)\\le C_1g_1(x),f_2(x)\\le C_2g_2(x)\\)</p> \\[ \\begin{aligned} \\lvert(f_1+f_2)(x)\\rvert&amp;=\\lvert f_1(x)+ f_2(x)\\rvert\\\\ &amp;\\le \\lvert f_1(x)\\rvert+\\lvert f_2(x)\\rvert\\\\ &amp;\\le C_1\\lvert g_1(x)\\rvert+C_2\\lvert g_2(x)\\rvert\\\\ &amp;\\le C_1\\lvert g(x)\\rvert+C_2\\lvert g(x)\\rvert\\\\ &amp;=C|g(x)| \\end{aligned} \\] <p>其中\\(C=C_1+C_2\\),\\(g(x)=\\max(g_1(x)+g_2(x))\\).</p> <p>推论1\\(\\qquad\\)如果\\(f_1(x)\\)和\\(f_2(x)\\)都是\\(O(g(x))\\),那么\\((f_1+f_2)(x)\\)也是\\(O(g(x))\\)的.</p> <p>定理3\\(\\qquad\\)如果\\(f_1(x)\\)是\\(O(g_1(x))\\),\\(f_2(x)\\)是\\(O(g_2(x))\\),那么\\((f_1f_2)(x)\\)是\\(O(g_1(x)g_2(x))\\)的.</p> <p>证明方法与定理2类似</p> <p>给出\\(f(x)=(x+1)\\log(x^2+1)+3x^2\\)的大\\(O\\)估算</p> <p>首先,\\(x+1\\)是\\(O(x)\\)的.\\(3x^2\\)是\\(O(x^2)\\)的 然后,当\\(x&gt;1\\)时,\\(x^2+1&lt;2x^2\\),因此当\\(x&gt;2\\)时,有</p> \\[ \\log(x^2+1)\\le\\log(2x^2)=\\log2+\\log x^2=\\log2+2\\log x\\le3\\log x \\] <p>根据定理3,\\((x+1)\\log(x^2+1)\\)是\\(O(x\\log x)\\). 根据定理2,\\(f(x)\\)是\\(O(\\max(x\\log x, x^2))\\). 又因为当\\(x&gt;1\\)时,\\(x^2&gt;x\\log x\\) 所以\\(f(x)\\)是\\(O(x^2)\\)的.</p>","path":["DiscreteMath","Chapter3 Algorithm","3.2 函数的增长"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter3%20Algorithm/function/#varomegavartheta","level":2,"title":"大\\(\\varOmega\\)和大\\(\\varTheta\\)记号","text":"<p>大\\(O\\)给出了函数增长的上界,但他无法指明函数的下界,因此使用大\\(\\varOmega\\)来表示函数增长的下界,使用大\\(\\varTheta\\)指明上界和下界.</p> <p>定义2\\(\\qquad\\)如果\\(f\\)和\\(g\\)是从整数集或实数集到实数集的函数,存在常数\\(C\\)和\\(k\\),当\\(x&gt;k\\)时有</p> \\[ \\lvert f(x)\\rvert\\ge C\\lvert g(x)\\rvert \\] <p>那么\\(f(x)\\)是\\(\\varOmega(g(x))\\)的.</p> <p>\\(f(x)\\)是\\(\\varOmega(g(x))\\)的当且仅当\\(g(x)\\)是\\(O(f(x))\\)的.</p> <p>定义3\\(\\qquad\\)如果\\(f\\)和\\(g\\)是从整数集或实数集到实数集的函数,且\\(f(x)\\)是\\(O(g(x))\\)的,同时\\(f(x)\\)是\\(\\varOmega(g(x))\\)的,那么\\(f(x)\\)是\\(\\varTheta(g(x))\\)的.</p> <p>若\\(f(x)\\)是\\(\\varTheta(g(x))\\),则\\(f(x)\\)是\\(g(x)\\)阶的,或者说\\(f(x)\\)和\\(g(x)\\)是同阶的</p> <p>判断\\(\\varTheta\\)的其他几种方法</p> <ul> <li>\\(f(x)\\)是\\(O(g(x))\\)的 ,同时\\(g(x)\\)是\\(O(f(x))\\)的</li> <li>存在实数\\(C_1\\),\\(C_2\\)和\\(k\\),当\\(x&gt;k\\)时,有 $$ C_1\\lvert g(x)\\rvert\\le f(x)\\le C_2\\lvert g(x)\\rvert $$</li> </ul> <p>定理4\\(\\qquad\\)令\\(f(x)=a_nx^n+a_{n-1}x^{n-1}+\\cdots+a_1x+a_0\\),其中\\(a_n,a_{n-1},\\cdots,a_1,a_0\\)是实数且\\(a_n\\ne0\\),那么\\(f(x)\\)是\\(x^n\\)阶的.</p>","path":["DiscreteMath","Chapter3 Algorithm","3.2 函数的增长"],"tags":["离散数学"]},{"location":"DiscreteMath/Chapter3%20Algorithm/function/#_2","level":2,"title":"补充","text":"<ol> <li>小\\(o\\)记号 当</li> </ol> \\[ \\lim_{x\\to\\infty}\\frac{f(x)}{g(x)}=0 \\] <p>时,\\(f(x)\\)是\\(o(g(x))\\)的.</p> <ol> <li>渐近 如果</li> </ol> \\[ \\lim_{x\\to\\infty}\\frac{f(x)}{g(x)}=1 \\] <p>那么\\(f(x)\\)和\\(g(x)\\)是渐进.记作\\(f(x)\\sim g(x)\\).</p>","path":["DiscreteMath","Chapter3 Algorithm","3.2 函数的增长"],"tags":["离散数学"]},{"location":"csapp/chapter2/","level":1,"title":"信息存储与表示","text":"","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_2","level":2,"title":"信息存储","text":"","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_3","level":3,"title":"十六进制表示法","text":"<p>十进制和十六进制表示之间的转换需要使用乘法或者除法来处理.一般情况,将一个十进制数字\\(x\\)转换为十六进制，可以反复地用\\(16\\)除\\(x\\),得到一个商\\(q\\)和一个余数\\(r\\),也就是\\(x=q\\times16+r\\).然后，我们用十六进制数字表示的\\(r\\)作为最低位数字,并且通过对\\(q\\)反复进行这个过程得到剩下的数字。</p> <p>例如,考虑十进制\\(314156\\)的转换:</p> \\[ \\begin{aligned} 314156 &amp; = 19635 \\times 16 + 12 &amp;\\qquad (C)\\\\ 19635 &amp; = 1227 \\times 16 + 3 &amp;\\qquad (2)\\\\ 1227 &amp; = 76 \\times 16 + 11 &amp;\\qquad(B) \\\\ 76 &amp; = 4 \\times 16 + 12 &amp;\\qquad (C)\\\\ 4 &amp; = 0 \\times 16 + 4 &amp;\\qquad (4) \\end{aligned}    \\] <p>所以,十进制数\\(314156\\)的十六进制表示为\\(\\mathrm{0x4CB2C}\\).</p> <p>同样的,将一个十六进制数字转换为十进制数字，我们可以用相应的\\(16\\)的幂乘以每个十六进制数字。</p> <p>例如:将十六进制数\\(\\mathrm{0x7AF}\\)转换为十进制:</p> \\[ 7\\times 16^2 + 10 \\times 16^1 + 15 \\times 16^0 = 7 \\times 256 + 10 \\times 16 + 15 \\times 1 = 1967 \\]","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_4","level":3,"title":"字数据的大小","text":"<p>寻址范围</p> <p>对于字长为\\(w\\)的计算机,它的寻址范围为\\(0\\sim 2^w-1\\),程序可以访问\\(2^w\\)字节. 32位字长限制虚拟地址空间为4千兆字节(写作4GB),扩展到 64 位字长使得虚拟地址空间为16EB, 大约是\\(1.84\\times10^{19}\\)字节。</p> <p>下图为 <code>C语言</code> 中的数据类型的大小,其中<code>int</code>和<code>long</code>的大小与编译器有关,通常在32位系统中为4字节,在64位系统中为8字节.</p> <p></p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_5","level":3,"title":"寻址和字节顺序","text":"<p>一个\\(w\\)位整数的位表示为:\\([x_{w-1},x_{w-2},\\cdots,x_1,x_0]\\),其中\\(x_{w-1}\\)为最高有效位,\\(x_0\\)为最低有效位. 最低有效位在前的表示方式为小端法,最高有效位在前的表示方法为大端法. 例如,对于数<code>0x01234567</code>,大端法和小端法的表示如下图 </p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#c","level":2,"title":"C语言中的位级运算","text":"","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_6","level":2,"title":"整数表示","text":"","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_7","level":3,"title":"无符号数的编码","text":"<p>可以将一个\\(w\\)位的整数表示为向量\\(\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_1,x_0]\\),对于\\(\\vec{x}\\)有</p> \\[ B2U_w(\\vec{x})\\doteq\\sum^{w-1}_{i=0}x_i2^{i} \\] <p>\\(B2U_2\\)是一个双射</p> 一些例子 \\[ \\begin{aligned} B2U_4([0001])&amp;=0\\cdot 2^3+0\\cdot 2^2+0\\cdot 2^1+1\\cdot 2^0=1\\\\ B2U_4([1011])&amp;=1\\cdot 2^3+0\\cdot 2^2+1\\cdot 2^1+1\\cdot 2^0=11\\\\ B2U_4([1111])&amp;=1\\cdot 2^3+1\\cdot 2^2+1\\cdot 2^1+1\\cdot 2^0=15\\\\ \\end{aligned} \\] <p>\\(UMax_w=2^{w-1}\\)</p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_8","level":2,"title":"补码编码","text":"<p>可以将一个\\(w\\)位的整数表示为向量\\(\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_1,x_0]\\),对于\\(\\vec{x}\\)有</p> \\[ B2T_w(\\vec{x})\\doteq -x_{w-1}\\cdot2^{w-1}+ \\sum^{w-2}_{i=0}x_i2^{i} \\] <p>\\(B2T_2\\)是一个双射</p> 一些例子 \\[ \\begin{aligned} B2T_4([0001])&amp;=-0\\cdot 2^3+0\\cdot 2^2+0\\cdot 2^1+1\\cdot 2^0=1\\\\ B2T_4([1011])&amp;=-1\\cdot 2^3+0\\cdot 2^2+1\\cdot 2^1+1\\cdot 2^0=-5\\\\ B2T_4([1111])&amp;=-1\\cdot 2^3+1\\cdot 2^2+1\\cdot 2^1+1\\cdot 2^0=-1\\\\ \\end{aligned} \\]","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_9","level":2,"title":"有符号数和无符号数的转换","text":"","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_10","level":2,"title":"整数运算","text":"","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_11","level":3,"title":"无符号加法","text":"<p>对于满足\\(0\\le x,y\\le 2^w\\)的\\(x\\)和\\(y\\)有</p> \\[ x+^u_w y= \\begin{cases} x+y,x+y&lt; 2^w\\\\ x+y-2^w,x+y&gt;2^w \\end{cases} \\] <p>检测无符号加法的溢出</p> <p>对于满足\\(0\\le x,y\\le 2^w\\)的\\(x\\)和\\(y\\),如果\\(x+y&lt; x\\)或者\\(x+y&lt; y\\),则溢出.</p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_12","level":2,"title":"补码加法","text":"<p>对于满足\\(TMin_w \\le x,y \\le TMax_w\\)的\\(x\\)和\\(y\\)有</p> \\[ x+^t_w y= \\begin{cases} x+y-2^w,&amp;x+y\\ge2^{w-1}\\qquad\\qquad&amp;\\text{正溢出}\\\\ x+y,&amp;-2^{w-1}\\le x+y&lt; 2^{w-1}\\\\ x+y+2^w,&amp;x+y&lt; -2^{w-1}\\qquad\\qquad&amp;\\text{负溢出} \\end{cases} \\] <p>检测补码加法的溢出</p> <p>对于满足\\(TMin_w \\le x,y \\le TMax_w\\)的\\(x\\)和\\(y\\),如果\\(x&lt; 0,y&lt; 0\\)且\\(x+y&gt;0\\)则负溢出;如果\\(x&gt;0,y&gt;0\\)且\\(x+y&lt; 0\\),则正溢出.</p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_13","level":2,"title":"补码的非","text":"<p>对于满足\\(TMin_w \\le x\\le TMax_w\\)的\\(x\\)有</p> \\[ -^t_w x = \\begin{cases} TMin_w, &amp;x=TMax_w\\\\ -x,&amp;x&gt;TMin_w \\end{cases} \\] <p>补码的非的位级表示</p> <p>方法1: 将\\(x\\)的每一位取反,然后加1. 即-x与~x+1的值是相同的.</p> <p>方法2: 假设\\(x\\)的位级表示为</p> \\[ [x_{w-1},x_{w-2},\\cdots,x_{k+1},1,0,\\cdots,0] \\] <p>其中,\\(k\\)为最右边的一个\\(1\\),只要\\(x\\ne0\\),就一定存在这样的\\(k\\).</p> <p>那么\\(-^t_w x\\)的位级表示为</p> \\[ [\\verb|~|x_{w-1},\\verb|~|x_{w-2},\\cdots,\\verb|~|x_{k+1},1,0,\\cdots,0] \\] <p>补码减法溢出判断</p> <ol> <li>如果\\(x&gt;0, y&lt;0\\)且\\(x-y&lt;0\\),则正溢出</li> <li>如果\\(x&lt;0, y&gt;0\\)且\\(x-y&gt;0\\),则负溢出</li> </ol>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_14","level":2,"title":"无符号乘法","text":"<p>对于满足\\(0\\le x,y\\le UMax_w\\)的\\(x\\)和\\(y\\)有 $$ x *^u_w y=(x\\cdot y)\\bmod 2^w $$</p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_15","level":2,"title":"补码乘法","text":"<p>对于满足\\(TMin_w \\le x,y \\le TMax_w\\)的\\(x\\)和\\(y\\)有 $$ x*^t_w y=U2T_w((x\\cdot y)\\bmod 2^w) $$</p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_16","level":2,"title":"乘以常数","text":"<p>乘以\\(2\\)的幂</p> <p>设无符号整数\\(x\\)的位级表示为\\([x_{w-1},x_{w-2},\\cdots,x_0]\\),那么,对于任意的\\(k\\ge0\\), 向\\(x\\)的右侧加\\(k\\)个\\(0\\)得到\\([x_{w-1},x_{w-2},\\cdots,x_0,\\cdots,0]\\)这是\\(x2^k\\)的位级表示</p> <p>与\\(2\\)的幂相乘的无符号乘法</p> <p>对于无符号整数\\(x\\)和\\(k\\),其中\\(0\\le k&lt; w\\),C表达式<code>x&lt;&lt;k</code>会得到\\(x*^u_w2^k\\)</p> <p>与\\(2\\)的幂相乘的补码乘法</p> <p>对于补码\\(x\\)和无符号整数\\(k\\),其中\\(0\\le k&lt; w\\),C表达式<code>x&lt;&lt;k</code>会得到\\(x*^u_w2^k\\)</p> <p>对于一组\\(0\\)和\\(1\\)交替的序列 $$ [(0\\cdots 0)(1\\cdots 1)\\cdots(0\\cdots 0)(1\\cdots 1)] $$ 对于一组从位位置\\(n\\)到位位置\\(m\\)的连续的\\(l\\)(\\(n\\le m\\)).可以用下面两种不同形式中的一种来计算这些位对乘积的影响</p> \\[ \\begin{aligned} &amp;\\text{形式A}:(x&lt;&lt;n)+(x&lt;&lt;(n-1))+\\cdots+(x&lt;&lt;m)\\\\ &amp;\\text{形式B}:(x&lt;&lt;(n+1))-(x&lt;&lt;m) \\end{aligned} \\]","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#2","level":2,"title":"除以2的幂","text":"","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_17","level":2,"title":"浮点数","text":"","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_18","level":3,"title":"二进制小数","text":"<p>与十进制小数类似,考虑一个形如</p> \\[ b_mb_{m-1}\\cdots b_1b_0.b_{-1}b_{-2}\\cdots b_{-n-1}b_{-n} \\] <p>的二进制小数,其中每个\\(b_i\\)都是\\(0\\)或\\(1\\).那么这个二进制小数的值为</p> \\[ b=\\sum^m_{i=-n}2^i\\times b_i \\] <p>例如,二进制数\\(101.11_2\\)表示数字\\(1\\times 2^2+0\\times 2^1+1\\times 2^0+1\\times 2^{-1}+1\\times 2^{-2}=5\\dfrac{3}{4}\\)</p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#ieee","level":3,"title":"IEEE浮点数","text":"<p>IEEE浮点标准用 \\(V=(-1)^s\\times M\\times 2^E\\) 来表示浮点数:</p> <ul> <li>符号 \\(s\\) 是符号位,决定了数的正负</li> <li>尾数 \\(M\\) 一个二进制数字,范围是 \\(1\\sim 2-\\epsilon\\),或者 \\(0\\sim 1-\\epsilon\\) .</li> <li>指数 \\(E\\) 是对浮点数加权</li> </ul> <p>将浮点数划分为三个部分,分别进行编码</p> <ul> <li>一个单独的符号位 \\(s\\)直接编码符号\\(s\\)。</li> <li>\\(k\\) 位的阶码字段 \\(exp=e_{k-1} \\cdots e_1 e_0\\)。编码阶码 \\(E\\)。</li> <li>\\(n\\) 位小数字段 \\(frac=f_{n-1} \\cdots f_1 f_0\\)编码尾数 \\(M\\), 但是编码出来的值也依赖于阶码字段的值是否等于0</li> </ul> <p></p> <p>给定位表示,根据<code>exp</code>的值，被编码的值可以分成三种不同的情况(最后一种情况有两个变种)</p> <p></p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#1","level":2,"title":"补充1:掩码","text":"","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_19","level":3,"title":"提取特定的位","text":"<p>要提取一个数中特定的位应使用<code>&amp;</code>,将要提取的位对应的mask设置为\\(1\\),其余的设置为\\(0\\). 例如 <pre><code>int x = 0xABCD;         // 二进制：1010101111001101\nint mask = 0xF;         //  0xF = 0000000000001111\nint result = x &amp; mask   //  结果是0xD = 0000000000001101\n</code></pre></p> <p>以上代码会提取\\(x\\)的低\\(4\\)位</p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#1_1","level":3,"title":"设置某些位为1","text":"<p>要设置特定的位为\\(1\\)应使用<code>|</code>,将要设置为\\(1\\)的位对应的mask设位\\(1\\),其余位为\\(0\\) 例如 <pre><code>int x = 0xA8;           // 二进制:0000000010101000\nint mask = 0x3          // 0x3 = 0000000000000011\nint result = x | mask;  // 结果是 0000000010101011\n</code></pre></p> <p>以上代码会将\\(x\\)的低\\(2\\)位设置为\\(1\\).</p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#0","level":3,"title":"清除某些位(设置为\\(0\\))","text":"<p>要清除特定的位为应使用<code>&amp;</code>,将要清除的位对应的mask设位\\(0\\),其余位为\\(1\\) 构造mask时,可以使用<code>~</code>和<code>&lt;&lt;</code> 如果要将第\\(m\\)位和第\\(n\\)位设置为0,则mask应为<code>(1&lt;&lt;m)|(1&lt;&lt;n)</code></p> <p>例如 <pre><code>int x = 0xA8;           // 二进制:0000000010101000\nint mask = ~(0xF)       // ~(0xF) = 111111110000\nint result = x &amp; mask;  // 结果是 0000000010100000\n</code></pre></p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#_20","level":3,"title":"取反某些位","text":"<p>要清除特定的位为应使用<code>^</code>(异或),将要取反的位对应的mask设位\\(1\\),其余位为\\(0\\) 例如 <pre><code>int x = 0xA8;           // 二进制:0000000010101000\nint mask = 0x7;         // 0x7 = 0000000000000111\nint result = x ^ mask;  //结果是 000000010101111\n</code></pre></p> <p>以上代码会将\\(x\\)的低\\(3\\)位取反.</p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#1_2","level":3,"title":"判断某些位是否为\\(1\\)","text":"<p>要判断一个数中特定的位应使用<code>&amp;</code>,将要判断的位对应的mask设置为\\(1\\),其余的设置为\\(0\\). 如果要判断的为全部为\\(1\\),那么结果将等于mask,即可以用<code>x &amp; mask == mask</code>进行判断 构造mask时,可以使用<code>~</code>和<code>&lt;&lt;</code> 如果要将第\\(m\\)位和第\\(n\\)位设置为0,则mask应为<code>(1&lt;&lt;m)|(1&lt;&lt;n)</code></p> <p>例如: <pre><code>int data = 0x8 // 00001000\nint mask = (1 &lt;&lt; 0) | (1 &lt;&lt; 3); // 00001001\nif (data &amp; mask) \n{ \n    // 第0位或第3位至少有一位是1 \n}\n</code></pre></p>","path":["Csapp","信息存储与表示"],"tags":[]},{"location":"csapp/chapter2/#2_1","level":1,"title":"补充2:逻辑非(<code>!</code>)与逻辑双非(<code>!!</code>)","text":"<p>逻辑非与逻辑双非可以格式化结果. 如果\\(p\\)为\\(0\\),则<code>!p</code>为1,<code>!!p</code>为0; 如果\\(p\\)非\\(0\\),则<code>!p</code>为0,<code>!!p</code>为1.</p>","path":["Csapp","信息存储与表示"],"tags":[]}]}